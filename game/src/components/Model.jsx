/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 models/model.glb 
*/

import React, { useEffect, useRef, forwardRef, useImperativeHandle } from 'react'
import { useGraph, useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { RigidBody, CapsuleCollider } from '@react-three/rapier'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from 'three'

export const Model = forwardRef((props, ref) => {
  const group = useRef()
  const rigidBodyRef = useRef()
  
  // Expose the group ref to parent components
  useImperativeHandle(ref, () => group.current, [])
  
  const { scene, animations } = useGLTF('/models/model.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions } = useAnimations(animations, group)
  
  const currentActionRef = useRef('idle')
  const previousActionRef = useRef('idle')
  // Using numeric keys like in the three.js example
  // key[0] = forward/backward, key[1] = left/right, key[2] = shift
  const keysRef = useRef([0, 0, 0])
  const rotateQuaternion = useRef(new THREE.Quaternion())
  const targetRotation = useRef(new THREE.Quaternion())
  const upVector = useRef(new THREE.Vector3(0, 1, 0))
  const rotateSpeed = 0.1
  
  // Movement settings
  const walkVelocity = 1.0
  const runVelocity = 2.5
  const moveDirection = useRef(new THREE.Vector3())
  const position = useRef(new THREE.Vector3())

  // Initialize animations
  useEffect(() => {
    if (!actions) return

    // Enable all animations and set initial weights
    const animationNames = ['idle', 'walk', 'run', 'jump']
    
    animationNames.forEach((name) => {
      if (actions[name]) {
        actions[name].enabled = true
        actions[name].setEffectiveTimeScale(1)
        actions[name].setEffectiveWeight(name === 'idle' ? 1 : 0)
        actions[name].play()
      }
    })
  }, [actions])

  // Handle keyboard input and animations
  useEffect(() => {
    const fadeDuration = 0.3

    const changeAnimation = (newAnimation) => {
      if (currentActionRef.current === newAnimation || !actions) return

      const current = actions[newAnimation]
      const old = actions[currentActionRef.current]

      if (!current || !old) return

      currentActionRef.current = newAnimation

      // Smooth transition with weight-based crossfading
      current.enabled = true
      current.setEffectiveTimeScale(1)
      current.setEffectiveWeight(1)
      current.time = 0
      
      old.crossFadeTo(current, fadeDuration, true)
    }

    const updateAnimation = () => {
      const key = keysRef.current
      const isMoving = key[0] !== 0 || key[1] !== 0
      const isShifting = key[2] === 1

      let newAnimation = 'idle'

      if (isMoving && isShifting) {
        newAnimation = 'run'
      } else if (isMoving) {
        newAnimation = 'walk'
      }

      changeAnimation(newAnimation)
    }

    const handleKeyDown = (event) => {
      const key = keysRef.current
      
      switch (event.code) {
        case 'ArrowUp':
          key[0] = -1
          break
        case 'ArrowDown':
          key[0] = 1
          break
        case 'ArrowLeft':
          key[1] = -1
          break
        case 'ArrowRight':
          key[1] = 1
          break
        case 'ShiftLeft':
        case 'ShiftRight':
          key[2] = 1
          break
        case 'Space':
          if (currentActionRef.current !== 'jump') {
            previousActionRef.current = currentActionRef.current
          }
          changeAnimation('jump')
          return
        default:
          return
      }
      
      updateAnimation()
    }

    const handleKeyUp = (event) => {
      const key = keysRef.current
      
      switch (event.code) {
        case 'ArrowUp':
          key[0] = key[0] < 0 ? 0 : key[0]
          break
        case 'ArrowDown':
          key[0] = key[0] > 0 ? 0 : key[0]
          break
        case 'ArrowLeft':
          key[1] = key[1] < 0 ? 0 : key[1]
          break
        case 'ArrowRight':
          key[1] = key[1] > 0 ? 0 : key[1]
          break
        case 'ShiftLeft':
        case 'ShiftRight':
          key[2] = 0
          break
        case 'Space':
          console.log(previousActionRef.current)
          changeAnimation(previousActionRef.current)
          return
        default:
          return
      }
      
      updateAnimation()
    }

    window.addEventListener('keydown', handleKeyDown)
    window.addEventListener('keyup', handleKeyUp)

    return () => {
      window.removeEventListener('keydown', handleKeyDown)
      window.removeEventListener('keyup', handleKeyUp)
    }
  }, [actions])

  // Update rotation and position based on movement direction
  useFrame((state, delta) => {
    if (!group.current || !rigidBodyRef.current) return

    const key = keysRef.current
    const isMoving = key[0] !== 0 || key[1] !== 0

    if (isMoving) {
      // Determine velocity based on whether running or walking
      const velocity = key[2] === 1 ? runVelocity : walkVelocity
      
      // Calculate angle based on key direction
      const angle = Math.atan2(key[1], key[0])
      
      // Create target rotation quaternion
      targetRotation.current.setFromAxisAngle(upVector.current, angle)
      
      // Smoothly rotate towards target
      group.current.quaternion.rotateTowards(targetRotation.current, rotateSpeed)
      
      // Calculate movement direction and set velocity
      moveDirection.current.set(key[1], 0, key[0]).normalize().multiplyScalar(velocity)
      
      // Get current velocity to maintain Y component (gravity)
      const currentVel = rigidBodyRef.current.linvel()
      
      // Set new velocity maintaining gravity
      rigidBodyRef.current.setLinvel({
        x: moveDirection.current.x,
        y: currentVel.y,
        z: moveDirection.current.z
      }, true)
    } else {
      // Stop horizontal movement when not moving
      const currentVel = rigidBodyRef.current.linvel()
      rigidBodyRef.current.setLinvel({
        x: 0,
        y: currentVel.y,
        z: 0
      }, true)
    }
  });

  return (
    <RigidBody
      ref={rigidBodyRef}
      colliders={false}
      mass={1}
      type="dynamic"
      position={[0, 2, 0]}
      enabledRotations={[false, false, false]}
      lockRotations
      friction={0.5}
    >
      <CapsuleCollider args={[0.2, 0.125]} position={[0, 0.325, 0]} />
      <group ref={group} {...props} scale={0.5} dispose={null}>
        <group name="Scene">
          <group name="AvatarRoot" rotation={[Math.PI / 2, 0, 0]}>
            <primitive object={nodes.Hips} />
            <skinnedMesh 
              name="AvatarBody" 
              geometry={nodes.AvatarBody.geometry} 
              material={materials.AvatarBody} 
              skeleton={nodes.AvatarBody.skeleton}
              castShadow
              receiveShadow
            />
            <skinnedMesh 
              name="AvatarLeftEyeball" 
              geometry={nodes.AvatarLeftEyeball.geometry} 
              material={materials.AvatarLeftEyeball} 
              skeleton={nodes.AvatarLeftEyeball.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="AvatarRightEyeball" 
              geometry={nodes.AvatarRightEyeball.geometry} 
              material={materials.AvatarRightEyeball} 
              skeleton={nodes.AvatarRightEyeball.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="AvatarTeethUpper" 
              geometry={nodes.AvatarTeethUpper.geometry} 
              material={materials.AvatarTeethUpper} 
              skeleton={nodes.AvatarTeethUpper.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="outfit_bottom" 
              geometry={nodes.outfit_bottom.geometry} 
              material={materials.outfit_bottom} 
              skeleton={nodes.outfit_bottom.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="outfit_shoes" 
              geometry={nodes.outfit_shoes.geometry} 
              material={materials.outfit_shoes} 
              skeleton={nodes.outfit_shoes.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="outfit_top" 
              geometry={nodes.outfit_top.geometry} 
              material={materials.outfit_top} 
              skeleton={nodes.outfit_top.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="AvatarEyelashes" 
              geometry={nodes.AvatarEyelashes.geometry} 
              material={materials.AvatarEyelashes} 
              skeleton={nodes.AvatarEyelashes.skeleton} 
              morphTargetDictionary={nodes.AvatarEyelashes.morphTargetDictionary} 
              morphTargetInfluences={nodes.AvatarEyelashes.morphTargetInfluences}
              castShadow
            />
            <skinnedMesh 
              name="AvatarHead" 
              geometry={nodes.AvatarHead.geometry} 
              material={materials.AvatarHead} 
              skeleton={nodes.AvatarHead.skeleton} 
              morphTargetDictionary={nodes.AvatarHead.morphTargetDictionary} 
              morphTargetInfluences={nodes.AvatarHead.morphTargetInfluences}
              castShadow
            />
            <skinnedMesh 
              name="AvatarTeethLower" 
              geometry={nodes.AvatarTeethLower.geometry} 
              material={materials.AvatarTeethLower} 
              skeleton={nodes.AvatarTeethLower.skeleton} 
              morphTargetDictionary={nodes.AvatarTeethLower.morphTargetDictionary} 
              morphTargetInfluences={nodes.AvatarTeethLower.morphTargetInfluences}
              castShadow
            />
          </group>
        </group>
      </group>
    </RigidBody>
  )
})

Model.displayName = 'Model'

useGLTF.preload('/models/model.glb')
