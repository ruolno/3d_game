/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 models/model.glb 
*/

import React, { useEffect, useRef, forwardRef, useImperativeHandle, useState } from 'react'
import { useGraph, useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { RigidBody, CapsuleCollider, useRapier } from '@react-three/rapier'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from 'three'

export const Model = forwardRef(({ 
  position: initialPosition = [0, 2, 0], 
  scale = 0.3, 
  camera,
  socket,
  playerId,
  remotePlayers = [],
  playerPositionsRef,
  isSeeker = false,
  onReportFound,
  gameState,
  ...props 
}, ref) => {
  const group = useRef()
  const rigidBodyRef = useRef()
  
  // Wait for physics world to be fully initialized before activating player
  const [physicsReady, setPhysicsReady] = useState(false)
  const rapier = useRapier()
  
  // Track last position update time
  const lastUpdateTime = useRef(0)
  const updateInterval = 50 // Send updates every 50ms (20 Hz) - increased for lower lag
  
  // Collision detection
  const collisionCooldown = useRef(new Map()) // Track cooldown per player
  const cooldownDuration = 2000 // 2 seconds cooldown between detections
  
  // Expose the group ref to parent components
  useImperativeHandle(ref, () => group.current, [])
  
  const { scene, animations } = useGLTF('/models/person/model.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions } = useAnimations(animations, group)
  
  // Wait for physics world to stabilize before enabling player physics
  useEffect(() => {
    // Give the physics world time to initialize all colliders
    const timer = setTimeout(() => {
      setPhysicsReady(true)
    }, 100) // Wait 100ms for scene colliders to be ready
    
    return () => clearTimeout(timer)
  }, [])
  
  const currentActionRef = useRef('idle')
  const previousActionRef = useRef('idle')
  // Using numeric keys like in the three.js example
  // key[0] = forward/backward, key[1] = left/right, key[2] = shift
  const keysRef = useRef([0, 0, 0])
  const rotateQuaternion = useRef(new THREE.Quaternion())
  const targetRotation = useRef(new THREE.Quaternion())
  const upVector = useRef(new THREE.Vector3(0, 1, 0))
  const rotateSpeed = 0.1
  
  // Movement settings (adjusted for smaller model scale)
  const walkVelocity = 0.5
  const runVelocity = 1.2
  const moveDirection = useRef(new THREE.Vector3())
  const position = useRef(new THREE.Vector3())

  // Initialize animations
  useEffect(() => {
    if (!actions) return

    // Enable all animations and set initial weights
    const animationNames = ['idle', 'walk', 'run', 'jump']
    
    animationNames.forEach((name) => {
      if (actions[name]) {
        actions[name].enabled = true
        actions[name].setEffectiveTimeScale(1)
        actions[name].setEffectiveWeight(name === 'idle' ? 1 : 0)
        actions[name].play()
      }
    })
  }, [actions])

  // Handle keyboard input and animations
  useEffect(() => {
    const fadeDuration = 0.3

    const changeAnimation = (newAnimation) => {
      if (currentActionRef.current === newAnimation || !actions) return

      const current = actions[newAnimation]
      const old = actions[currentActionRef.current]

      if (!current || !old) return

      currentActionRef.current = newAnimation

      // Smooth transition with weight-based crossfading
      current.enabled = true
      current.setEffectiveTimeScale(1)
      current.setEffectiveWeight(1)
      current.time = 0
      
      old.crossFadeTo(current, fadeDuration, true)
    }

    const updateAnimation = () => {
      const key = keysRef.current
      const isMoving = key[0] !== 0 || key[1] !== 0
      const isShifting = key[2] === 1

      let newAnimation = 'idle'

      if (isMoving && isShifting) {
        newAnimation = 'walk'
      } else if (isMoving) {
        newAnimation = 'run'
      }

      changeAnimation(newAnimation)
    }

    const handleKeyDown = (event) => {
      const key = keysRef.current
      
      switch (event.code) {
        case 'ArrowUp':
          key[0] = -1
          break
        case 'ArrowDown':
          key[0] = 1
          break
        case 'ArrowLeft':
          key[1] = -1
          break
        case 'ArrowRight':
          key[1] = 1
          break
        case 'ShiftLeft':
        case 'ShiftRight':
          key[2] = 1
          break
        case 'Space':
          if (currentActionRef.current !== 'jump') {
            previousActionRef.current = currentActionRef.current
          }
          changeAnimation('jump')
          return
        default:
          return
      }
      
      updateAnimation()
    }

    const handleKeyUp = (event) => {
      const key = keysRef.current
      
      switch (event.code) {
        case 'ArrowUp':
          key[0] = key[0] < 0 ? 0 : key[0]
          break
        case 'ArrowDown':
          key[0] = key[0] > 0 ? 0 : key[0]
          break
        case 'ArrowLeft':
          key[1] = key[1] < 0 ? 0 : key[1]
          break
        case 'ArrowRight':
          key[1] = key[1] > 0 ? 0 : key[1]
          break
        case 'ShiftLeft':
        case 'ShiftRight':
          key[2] = 0
          break
        case 'Space':
          console.log(previousActionRef.current)
          changeAnimation(previousActionRef.current)
          return
        default:
          return
      }
      
      updateAnimation()
    }

    window.addEventListener('keydown', handleKeyDown)
    window.addEventListener('keyup', handleKeyUp)

    return () => {
      window.removeEventListener('keydown', handleKeyDown)
      window.removeEventListener('keyup', handleKeyUp)
    }
  }, [actions])

  // Update rotation and position based on movement direction
  useFrame((state, delta) => {
    if (!group.current || !rigidBodyRef.current || !camera) return

    const key = keysRef.current
    const isMoving = key[0] !== 0 || key[1] !== 0

    if (isMoving) {
      // Determine velocity based on whether running or walking
      const velocity = key[2] === 1 ? walkVelocity : runVelocity
      
      // Get camera's forward direction (projected onto XZ plane)
      const cameraDirection = new THREE.Vector3()
      camera.getWorldDirection(cameraDirection)
      cameraDirection.y = 0 // Project to XZ plane
      cameraDirection.normalize()
      
      // Get camera's right direction
      const cameraRight = new THREE.Vector3()
      cameraRight.crossVectors(cameraDirection, upVector.current).normalize()
      
      // Calculate movement direction based on camera orientation
      // key[0]: forward(-1)/backward(1), key[1]: left(-1)/right(1)
      moveDirection.current.set(0, 0, 0)
      moveDirection.current.addScaledVector(cameraDirection, -key[0]) // Forward/backward
      moveDirection.current.addScaledVector(cameraRight, key[1]) // Left/right
      moveDirection.current.normalize().multiplyScalar(velocity)
      
      // Calculate target rotation based on movement direction
      const angle = Math.atan2(moveDirection.current.x, moveDirection.current.z)
      targetRotation.current.setFromAxisAngle(upVector.current, angle)
      
      // Smoothly rotate towards target
      group.current.quaternion.rotateTowards(targetRotation.current, rotateSpeed)
      
      // Get current velocity to maintain Y component (gravity)
      const currentVel = rigidBodyRef.current.linvel()
      
      // Set new velocity maintaining gravity
      rigidBodyRef.current.setLinvel({
        x: moveDirection.current.x,
        y: currentVel.y,
        z: moveDirection.current.z
      }, true)
    } else {
      // Stop horizontal movement when not moving
      const currentVel = rigidBodyRef.current.linvel()
      rigidBodyRef.current.setLinvel({
        x: 0,
        y: currentVel.y,
        z: 0
      }, true)
    }

    // Send position updates to server (throttled)
    const now = Date.now()
    if (socket && playerId && now - lastUpdateTime.current > updateInterval) {
      const worldPos = new THREE.Vector3()
      group.current.getWorldPosition(worldPos)
      
      const worldRot = new THREE.Euler()
      worldRot.setFromQuaternion(group.current.quaternion)
      
      socket.emit('player:update', {
        position: { x: worldPos.x, y: worldPos.y, z: worldPos.z },
        rotation: { x: worldRot.x, y: worldRot.y, z: worldRot.z }
      })
      
      lastUpdateTime.current = now
    }

    // Collision detection with other players (only if seeker and in seeking phase)
    if (isSeeker && gameState?.state === 'seeking' && remotePlayers.length > 0) {
      const myPosition = new THREE.Vector3()
      group.current.getWorldPosition(myPosition)
      
      remotePlayers.forEach(player => {
        // Skip already caught players
        if (player.isCaught) return
        
        // Check cooldown
        const lastCollision = collisionCooldown.current.get(player.id)
        if (lastCollision && now - lastCollision < cooldownDuration) return
        
        // Read real-time position from shared ref (same source RemotePlayer uses)
        const liveData = playerPositionsRef?.current?.get(player.id)
        const pos = liveData?.position ?? player.position
        
        const otherPosition = new THREE.Vector3(pos.x, pos.y, pos.z)
        const distance = myPosition.distanceTo(otherPosition)
        
        // Collision threshold (considering scale)
        const collisionThreshold = 0.8 * scale
        if (distance < collisionThreshold) {
          // Found a hider!
          console.log(`Found player: ${player.name}`)
          collisionCooldown.current.set(player.id, now)
          
          if (onReportFound) {
            onReportFound(player.id)
          }
        }
      })
    }
  });

  return (
    <RigidBody
      ref={rigidBodyRef}
      colliders={false}
      mass={1}
      type={physicsReady ? "dynamic" : "kinematicPosition"}
      position={initialPosition}
      enabledRotations={[false, false, false]}
      friction={0.5}
      gravityScale={physicsReady ? 1 : 0}
    >
      {/* Capsule collider: args=[cylinderHeight, radius]
          Total height = cylinderHeight + 2*radius
          Rounded bottom helps climb stairs/curbs smoothly
          Model offset down by radius so feet touch ground */}
      <CapsuleCollider 
         args={[0.55 * scale, 0.4 * scale]} 
         position={[0, 0.55 * scale, 0]} 
      /> 
      <group ref={group} {...props} scale={scale} position={[0, -0.3 * scale, 0]} dispose={null}>
        <group name="Scene">
          <group name="AvatarRoot" rotation={[Math.PI / 2, 0, 0]}>
            <primitive object={nodes.Hips} />
            <skinnedMesh 
              name="AvatarBody" 
              geometry={nodes.AvatarBody.geometry} 
              material={materials.AvatarBody} 
              skeleton={nodes.AvatarBody.skeleton}
              castShadow
              receiveShadow
            />
            <skinnedMesh 
              name="AvatarLeftEyeball" 
              geometry={nodes.AvatarLeftEyeball.geometry} 
              material={materials.AvatarLeftEyeball} 
              skeleton={nodes.AvatarLeftEyeball.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="AvatarRightEyeball" 
              geometry={nodes.AvatarRightEyeball.geometry} 
              material={materials.AvatarRightEyeball} 
              skeleton={nodes.AvatarRightEyeball.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="AvatarTeethUpper" 
              geometry={nodes.AvatarTeethUpper.geometry} 
              material={materials.AvatarTeethUpper} 
              skeleton={nodes.AvatarTeethUpper.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="outfit_bottom" 
              geometry={nodes.outfit_bottom.geometry} 
              material={materials.outfit_bottom} 
              skeleton={nodes.outfit_bottom.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="outfit_shoes" 
              geometry={nodes.outfit_shoes.geometry} 
              material={materials.outfit_shoes} 
              skeleton={nodes.outfit_shoes.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="outfit_top" 
              geometry={nodes.outfit_top.geometry} 
              material={materials.outfit_top} 
              skeleton={nodes.outfit_top.skeleton}
              castShadow
            />
            <skinnedMesh 
              name="AvatarEyelashes" 
              geometry={nodes.AvatarEyelashes.geometry} 
              material={materials.AvatarEyelashes} 
              skeleton={nodes.AvatarEyelashes.skeleton} 
              morphTargetDictionary={nodes.AvatarEyelashes.morphTargetDictionary} 
              morphTargetInfluences={nodes.AvatarEyelashes.morphTargetInfluences}
              castShadow
            />
            <skinnedMesh 
              name="AvatarHead" 
              geometry={nodes.AvatarHead.geometry} 
              material={materials.AvatarHead} 
              skeleton={nodes.AvatarHead.skeleton} 
              morphTargetDictionary={nodes.AvatarHead.morphTargetDictionary} 
              morphTargetInfluences={nodes.AvatarHead.morphTargetInfluences}
              castShadow
            />
            <skinnedMesh 
              name="AvatarTeethLower" 
              geometry={nodes.AvatarTeethLower.geometry} 
              material={materials.AvatarTeethLower} 
              skeleton={nodes.AvatarTeethLower.skeleton} 
              morphTargetDictionary={nodes.AvatarTeethLower.morphTargetDictionary} 
              morphTargetInfluences={nodes.AvatarTeethLower.morphTargetInfluences}
              castShadow
            />
          </group>
        </group>
      </group>
    </RigidBody>
  )
})

Model.displayName = 'Model'

useGLTF.preload('/models/model.glb')
